#!/usr/bin/env ruby

# ------------------------------------------------------------------------------
# Simple Amazon EC2 instance manager
# --kmatthias Tue Apr 13 20:52:25 PDT 2010
# ------------------------------------------------------------------------------

# Many values are read from the YAML config ~/.ec2rc.  Run 'ec2 config' to
# create it for the first time.

require 'rubygems'
require 'amazon_sdb'
require 'right_aws'
require 'yaml'

# Give RightAWS the certificate authority file to avoid warnings and be more secure
Rightscale::HttpConnection.params[:ca_file] = File.join(File.expand_path(File.dirname(__FILE__)), 'ca-certificates.crt')

$all_instances = nil

class String
	def underscore
		self.gsub(/::/, '/').
			gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
			gsub(/([a-z\d])([A-Z])/,'\1_\2').
			tr("-", "_").
			downcase
	end
end

class SDB

	def initialize
		# This does not actually stay connected, it's stateless
		@b = Amazon::SDB::Base.new($config['access_key'], $config['secret_access_key'])
		@sdb_domain = @b.domain 'ec2_names'

		if @sdb_domain.nil?
			# Try to make a new domain if we can't find an existing one
			@sdb_domain = b.create_domain 'ec2_names'
		end

		if @sdb_domain.nil?
			raise SocketError, "Unable to connect to ec2_names domain on SDB."
		end
	end

	def get_attributes name
		attrs = {}
		begin
			attrs = @sdb_domain.get_attributes(name).attributes.to_h
		rescue Amazon::SDB::RecordNotFoundError
			# do nothing
		end

		return attrs
	end

	def put_attributes name, attrs
		values = Amazon::SDB::Multimap.new
		# Multimap won't take hash as a param to the constructor...
		attrs.each { |key, value| values[key] = value }

		@sdb_domain.put_attributes(name, values)
	end

	def delete_attributes name
		entry = nil
		begin
			entry = @sdb_domain.get_attributes name
			entry.destroy!
		rescue Amazon::SDB::RecordNotFoundError
			# do nothing
		end
	end

	def get_all
		@sdb_domain.query
	end

end

class EC2Instances

	def initialize
		@sdb = SDB.new
		@cached_fields = [ "@parsed_info", "@id_name_map" ]

		if File.exist? cache_file
			if File.new(cache_file).mtime.to_i > (Time.now.to_i - (60 * 60)) # 1 hour cache time
				cached_values = File.open(cache_file) { |yf| YAML::load(yf) }
				return if !cached_values
				@cached_fields.each { |field| self.instance_variable_set(field, cached_values[field]) if cached_values[field] }
			end
		end
	end

	def cache_file 
		File.join(ENV['HOME'], ".ec2cache")
	end

	def ec2
		return @ec2_object if @ec2_object

		@ec2_object = begin
			options = { :cache => true, :logger => Logger.new(File.open("/dev/null", "w")) }
			RightAws::Ec2.new($config['access_key'], $config['secret_access_key'], options) || raise(SocketError, "Unable to connect to EC2 API.")
		end

		return @ec2_object
	end

	def info
		return @parsed_info if @parsed_info
		old = $stderr
		$stderr = StringIO.new

		begin
			@raw_info ||= ec2.describe_instances
		ensure
			$stderr = old
		end

		@parsed_info = {}
		@raw_info.each { |entry| @parsed_info[entry[:aws_instance_id]] = EC2Instance.new entry }

		cache
		return @parsed_info
	end

	def cache
		cached_values = {}
		@cached_fields.each { |field| cached_values[field] = self.instance_variable_get field }
		cache_file = File.join(ENV['HOME'], ".ec2cache")
		File.open(cache_file, 'w') { |file| file.write(YAML.dump(cached_values)) }
	end

	def ids_to_names
		return @id_name_map if @id_name_map

		@id_name_map = {}
		keys = @sdb.get_all
		keys.each do |k|
			@id_name_map[id_for_name k.key] = k.key
		end

		cache
		return @id_name_map
	end

	def get_instance arg
		return info[arg] if info[arg]

		id = id_for_name(arg)
		info[id]
	end

	def id_for_name name
		return if name.nil?

		attrs = @sdb.get_attributes(name)
		return attrs['aws_instance_id']
	end

	def name_instance name, instance_id
		attrs = @sdb.get_attributes(instance_id)

		if attrs['aws_instance_id']
			raise RuntimeError, "Error: Amazon SDB already has the value: #{attrs['instance_id']}"
		end

		instance = get_instance(instance_id)

		if instance.nil?
			raise RuntimeError, "Can't find information about #{instance_id}"
		end

		@sdb.put_attributes(name, instance)
		@raw_info = nil
	end

	def hostname_to_ip hostname
		# Parse the hostname rather than doing a (slow) DNS lookup
		fields = hostname.split "-"
		if fields.size > 0
			return "#{fields[1]}.#{fields[2]}.#{fields[3]}.#{(fields[4]||'').gsub(/\..*/,'')}"
		else
			return ""
		end
	end

	def flush
		require 'fileutils'
		# Clear cache for this process...
		@cached_fields.each { |field| self.instance_variable_set field, nil }

		# Clear it for future processes...
		FileUtils.rm cache_file
	end
end

class EC2Instance < Hash

	def initialize hash
		self.merge! hash
	end

	def username
		# TODO: this should be settable in SDB rather than trying to figure it out here
		self.ssh_key_name =~ /ubuntu-images/ ? 'ubuntu' : 'root'
	end

	def name
		$all_instances.ids_to_names[aws_instance_id] || aws_instance_id
	end

	def key
		path = File.expand_path $config['ssh_key_path']

		if File.exist?(File.join(path, ssh_key_name))
			key = File.join(path, ssh_key_name)
		elsif File.exist?(File.join(path, "#{ssh_key_name}.pem"))
			key = File.join(path, "#{ssh_key_name}.pem")
		elsif File.exist?(File.join(path, "#{ssh_key_name}-key"))
			key = File.join(path, "#{ssh_key_name}-key")
		end

		return key
	end

	def ssh args
		# Call SSH and pass through all the other ssh options
		exec "ssh -i #{self.key} #{self.username}@#{self.dns_name} #{args[1..args.size].join(' ')}"
	end

	def scp args
		host = args.detect { |a| a =~ /\S+:/ }
		junk, file = host.split(':')

		username = self.username
		username, junk = host.split('@') if host =~ /@/

		filtered_args = args.map do |arg|
			if arg =~ /#{self.name}/
				"#{username}@#{self.dns_name}:#{file}"
			else
				arg
			end
		end

		# Call SCP and filter through all the other options
		exec "scp -i #{self.key} #{filtered_args.join(' ')}"
	end

	def method_missing(method, *params)
		method = method.to_sym
		return self[method] if self.keys.collect(&:to_sym).include?(method)
		super
	end
end

class EC2Command

	def initialize
		$all_instances ||= EC2Instances.new
	end

	def ec2
		EC2Instances.ec2
	end

	# Get and set EC2 instance names
	def name args
		if args.size == 1

			begin
				puts $all_instances.id_for_name args[0]
			rescue SocketError => e
				raise RuntimeError,"Can't connect to Amazon SDB.  No connectivity? "
			rescue RuntimeError => e
				STDERR.puts "Not an instance name."
			end
			return

		elsif args.size == 2

			$all_instances = EC2Instances.new
			$all_instances.name_instance(args[0], args[1])
			return

		end

		puts "Usage: ec2 name <human readable name>				--> retrieve a value"
		puts "	   ec2 name <human readable name> <instance ID>  --> set a value"
	end

	# Show all instances, with nice names when available
	def list not_used
		info = $all_instances.info
		puts "-"*95
		puts "Instance	AMI		Key		Size		Date		Public IP"
		puts "-"*95

		all = info.keys.map do |key|
			entry = info[key]
			name = $all_instances.ids_to_names[entry[:aws_instance_id]] ?
				$all_instances.ids_to_names[entry[:aws_instance_id]] : entry[:aws_instance_id]
			[
				sprintf("%-15s", name),
				entry[:aws_image_id],
				sprintf("%13s", entry[:ssh_key_name]),
				entry[:aws_instance_type],
				entry[:aws_launch_time].gsub!(/T.*$/, ''),
				$all_instances.hostname_to_ip(entry[:dns_name])
			]
		end

		all.sort { |a, b| a[4] <=> b[4] }.each { |entry| puts entry.join("	") }

		puts "-"*95
	end

	# Connect to a named instance over ssh
	def ssh args
		instance = $all_instances.get_instance(args.first)

		if !instance
			raise RuntimeError, "Can't find host from command string (#{args.join(' ')})."
		end

		instance.ssh args
	end

	# Copy files to/from remote named instances over SSH
	def scp args
		host = args.detect { |a| a =~ /\S+:/ }
		hostname, junk = host.split(':')
		hostname = hostname.sub(/.*@/, '')

		instance = $all_instances.get_instance(hostname)
		if !instance
			raise RuntimeError, "Can't find host from command string (#{args.join(' ')})."
		end

		instance.scp args
	end

	# OSX-specific: open browser to instance, using HTTP on port 80
	def http args
		instance = $all_instances.get_instance(args.first)

		if instance.nil?
			raise RuntimeError, "Can't find host from command string"
		end

		exec "open -a #{$config['web_browser']} http://#{instance.dns_name}/"
	end

	# Edit the config file (or create if none)
	def config args
		config_path = File.join(ENV['HOME'], ".ec2rc")
		if !File.exist? config_path
			File.open(config_path, "w") do |file|
				text = <<-EOF.gsub(/^\t{4}/, '')
				---
				# Where your SSH keys are on the disk
				ssh_key_path:
				# Which browser you wish to use for HTTP
				web_browser: /Applications/Firefox.app
				# AWS keys
				access_key:
				secret_access_key:
				# Custom plugins can be loaded thus:
				#
				# custom_commands:
				#   RemoteCommands: ~/.ec2_remote_commands

				EOF
				file.write text
			end
		end

		if ENV.has_key? 'EDITOR'
			exec "#{ENV['EDITOR']} #{config_path}"
		else
			exec "vim #{config_path}"
		end
	end

	# Write hosts to STDOUT
	def ssh_config(*args)
		collection = $all_instances.info
		strings = collection.keys.map do |instance_name|
			instance = EC2Instance.new(collection[instance_name])
			"Host #{instance.name}\n	IdentityFile #{instance.key}\n	HostName #{instance.dns_name}\n	User #{instance.username}"
		end
		puts strings.join("\n\n")
	end

	def flush args
		$all_instances.flush
		puts "Cache flushed."
	end
end


# ------------------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------------------

# We can be called like 'ec2 name ...' or 'ec2-name ...'
if $0 == 'ec2'
	ARGV.slice! 0
elsif $0 =~ /ec2-([a-z]+)$/
	ARGV.unshift($1)
end

# Load config hash
if File.exist? File.join(ENV['HOME'], '.ec2rc')
	$config = YAML.load_file(File.join(ENV['HOME'], '.ec2rc'))
else

	if $ARGV[0] != 'config'
		STDERR.print "Can't open your .ec2rc file.  "
		STDERR.puts "Consider running 'ec2 config' to create it."
	end

	$config = {}
end

command = EC2Command.new
$plugins = []

# Load commands plugins described in the config
if $config.has_key?('custom_commands') && $config['custom_commands'].size > 0

	$config['custom_commands'].each do |name, path|
		full_path = File.expand_path("#{path}.rb")

		if !File.exists? full_path
			STDERR.puts "Failed adding #{name} command module from #{path}: File not found."
			next
		end

		require full_path
		command.extend name.constantize
		$plugins << name
	end
end

if $0 !~ /spec$/

	# Command names
	begin
		if ARGV.size > 0
			if command.respond_to? ARGV[0]
				command.send ARGV[0], ARGV[1..ARGV.size]
				exit
			else
				puts "Invalid command."
			end
		end
	rescue RuntimeError => e
		# Generally we don't want the stack trace for our errors
		STDERR.puts e.to_s
		exit 1
	end
	
	# Usage for the main command object
	puts "Usage: ec2 [command]"
	puts "	Commands:"
	puts "	  - config       --> Edit existing or a create new configuration file"
	puts "	  - flush        --> Flush the Field Marshal instance cache manually"
	puts "	  - http         --> Connect to port 80 on the instance in a web browser"
	puts "	  - list         --> List instances"
	puts "	  - name         --> Set a name or get the instance ID for a name"
	puts "	  - scp          --> Copy a file to or from the instance using scp"
	puts "	  - ssh          --> Connect to the instance over ssh"
	puts "	  - ssh_config   --> List hosts in an ssh_config friendly format"

	$plugins.each do |plugin|
		usage_method = "#{plugin.to_s.underscore}_usage"
		if command.respond_to? usage_method
			command.send usage_method
		end
  end
end
